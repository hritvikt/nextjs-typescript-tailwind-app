{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 180, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/src/app/api/download/app/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport archiver from 'archiver';\nimport { existsSync } from 'fs';\nimport { join } from 'path';\n\nexport async function GET() {\n  try {\n    // Create a new archive\n    const archive = archiver('zip', {\n      zlib: { level: 9 } // Maximum compression\n    });\n\n    // Create a transform stream to collect chunks\n    const chunks: any[] = [];\n    archive.on('data', (chunk) => chunks.push(chunk));\n\n    // List of files/folders to include\n    const filesToInclude = [\n      'src',\n      'public',\n      '.gitignore',\n      'package.json',\n      'tsconfig.json',\n      'next.config.ts',\n      'README.md',\n      'components.json',\n      'eslint.config.mjs',\n      'postcss.config.mjs'\n    ];\n\n    // Add files to the archive\n    for (const fileOrDir of filesToInclude) {\n      const filePath = join(process.cwd(), fileOrDir);\n      if (existsSync(filePath)) {\n        if (fileOrDir.includes('/')) {\n          archive.directory(filePath, fileOrDir);\n        } else {\n          archive.file(filePath, { name: fileOrDir });\n        }\n      }\n    }\n\n    // Finalize the archive and wait for it to complete\n    await new Promise((resolve, reject) => {\n      archive.on('end', resolve);\n      archive.on('error', reject);\n      archive.finalize();\n    });\n\n    // Combine all chunks into a single buffer\n    const zipBuffer = Buffer.concat(chunks);\n\n    // Create a Response with the ZIP buffer\n    return new Response(zipBuffer, {\n      status: 200,\n      headers: {\n        'Content-Type': 'application/zip',\n        'Content-Disposition': 'attachment; filename=\"app-package.zip\"',\n        'Content-Length': zipBuffer.length.toString()\n      }\n    });\n  } catch (error) {\n    console.error('Error generating ZIP:', error);\n    return new Response('Failed to generate ZIP file', { status: 500 });\n  }\n}\n"],"names":[],"mappings":";;;AACA;AACA;AACA;;;;AAEO,eAAe;IACpB,IAAI;QACF,uBAAuB;QACvB,MAAM,UAAU,CAAA,GAAA,mIAAA,CAAA,UAAQ,AAAD,EAAE,OAAO;YAC9B,MAAM;gBAAE,OAAO;YAAE,EAAE,sBAAsB;QAC3C;QAEA,8CAA8C;QAC9C,MAAM,SAAgB,EAAE;QACxB,QAAQ,EAAE,CAAC,QAAQ,CAAC,QAAU,OAAO,IAAI,CAAC;QAE1C,mCAAmC;QACnC,MAAM,iBAAiB;YACrB;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;SACD;QAED,2BAA2B;QAC3B,KAAK,MAAM,aAAa,eAAgB;YACtC,MAAM,WAAW,CAAA,GAAA,iGAAA,CAAA,OAAI,AAAD,EAAE,QAAQ,GAAG,IAAI;YACrC,IAAI,CAAA,GAAA,6FAAA,CAAA,aAAU,AAAD,EAAE,WAAW;gBACxB,IAAI,UAAU,QAAQ,CAAC,MAAM;oBAC3B,QAAQ,SAAS,CAAC,UAAU;gBAC9B,OAAO;oBACL,QAAQ,IAAI,CAAC,UAAU;wBAAE,MAAM;oBAAU;gBAC3C;YACF;QACF;QAEA,mDAAmD;QACnD,MAAM,IAAI,QAAQ,CAAC,SAAS;YAC1B,QAAQ,EAAE,CAAC,OAAO;YAClB,QAAQ,EAAE,CAAC,SAAS;YACpB,QAAQ,QAAQ;QAClB;QAEA,0CAA0C;QAC1C,MAAM,YAAY,OAAO,MAAM,CAAC;QAEhC,wCAAwC;QACxC,OAAO,IAAI,SAAS,WAAW;YAC7B,QAAQ;YACR,SAAS;gBACP,gBAAgB;gBAChB,uBAAuB;gBACvB,kBAAkB,UAAU,MAAM,CAAC,QAAQ;YAC7C;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO,IAAI,SAAS,+BAA+B;YAAE,QAAQ;QAAI;IACnE;AACF","debugId":null}}]
}